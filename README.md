# Subversion 활용 workbook

본 문서는 subversion을 이용한 버젼 관리 시스템 활용을 돕기 위한 짧은 워크북 자료이다.

## 클라이언드 프로그램 설치

## version control system 의 기본 개념

version control은 복수의 사용자가 복수의 컴퓨터에서 공통 작업 자료에 접근해서 동시에 파일을 생성, 삭제, 삽입, 수정, 이동 등의 작업을 가능케 하기 위해 제안된 개념이다. 이러한 개념을 프로그램으로 구현한 예가 cvs, sourcesafe등이 있었으며, 최근에는 subversion과 git가 많이 사용되고 있다. 회의 내부 팀, 대학의 연구실 등 작은 그룹 내부에서만 파일을 공유하고 동시 개발을 진행할 경우는 subversion으로 충분하다.

그림과 같이 이제 저장소를 중심으로 파일을 관리하고 공동작업하기로 하였다고 가정한다. 저장소 생성은 본 문서의 범위를 벗어나므로 생략하기로 한다. 생성된 저장소를 repository라고도 부른다. 로컬 사용자는 이 저장소를 로컬 영역으로 복제하여 작업을 시작한다. 여러 사용자가 저장소를 자신의 컴퓨터에 복제하여 작업을 동시에 시작할 수 있다. 로컬 사용자가 로컬 컴퓨터에서 생성한 각종 파일들은 여전히 로컬 컴퓨터에만 존재하는 파일이며 아직 중앙 저장소에 관리되지 않는 파일이다. 파일 일부 혹은 전부를 중앙저장소에 등록하여 관리하기로 하였다면 svn add 를 수행하여 파일을 svn에 등록한다. svn commit이라는 명령어를 수행하지 않으면 로컬에서 등록된 이 파일들이 서버로 전송되지 않는다. 파일 수정이 끝났다면 이제 최종적으로 서버 저장소로 파일을 전송해야 한다. 우리는 이 작업을 commit이라고 하고 저장소의 파일의 버젼이 1 증가된다. 

다른 사용자의 작업중인 컴퓨터에 방금 서버 저장소에 변경된 내용이 바로 로컬 폴더로 다운로드 되는 것은 아니다. 사용자가 서버로부터 checkout/update 받고서 작섭을 시작할 당시는 저장소의 내용이 최신이며 로컬 폴더의 내용도 최신 파일과 동기가 되어 최신 파일이었을 것이다. 하지만 이후에 서버의 저장소의 내용이 업데이트 되었으므로, 그 내용을 또다른 사용자가 적용받고 싶다면 svn update라는 명령어를 명시적으로 수행해야 한다. 이는 내가 현재 작업 중인 내용이 있는데 외부 사장자가 변경한 내용이 나의 작업중인 파일에 그대로 적용되는 위험을 막기 위함이다. 사용자가 작업중인 것 외에는 자연스럽게 서버 저장소의 최신 버젼의 파일들의 자신의 로컬 폴더로 다운로드 되며 혹시 내가 작업중인 파일을 다른 사용자가 변경하여 commit했다면 update 수행시 나의 작업과 다른 사용자의 작업이 merge될 것이다. 공교롭게도 같은 라인을 수정했다면 conflict가 나며 수동으로 결합을 시도해야 한다.



## checkout

저장소로부터 로컬 폴더로 최초 한번 가지고 올때, 즉 로컬 카피를 생성하는 작업이다. 저장소가 만약 https://svn.server.net/FOO 라면 다음의 명령어를 실행하면 저장소의 local copy를 생성할 수 있다.

``` shell
% svn checkout https://svn.server.net/FOO
% ls 
FOO/
```
저장소를 checkout 후 현재 폴더에 저장소 이름과 같은 이름의 디렉토리가 생성되고 그 밑에 저장소 파일들이 모두 복제되어 저장됨을 알 수 있다.

## add

이제 파일을 생성하고 그것을 svn 저장소에 등록해보자. 앞에서도 언급한 것처럼 로컬에서 작업한 모든 파일들은 그 자체로 파일일뿐 서버 저장소와 아무런 관련이 없다. 하지만 svn add [file]이란 명령어를 통해 파일을 저장소에서 관리하겠다고 등록하게 되면 이제부터 현재 사용자의 작업에 의한 modify, delete, update등이 서버에 영향을 주며 다른 사용자가 작업한 동일 한 내용도 나의 로컬 파일에 적용된다.

``` shell
% vi foo.c
% svn status
foo.c    ?
```
파일을 생성한 후 svn status를 실행하면 현재 폴더아래의 파일들이 어떻게 관리되고 있는지 표시된다. 아직 foo.c를 svn 저장소에 등록하기 전이므로 ?가 표시된다. 즉 이 파일은 저장소와 무관함을 의미한다. 

``` shell
% svn add foo.c
% svn status
foo.c    A
```

이제 svn add를 이용하여 파일을 등록한다. 이후에 다시 svn status 명령어를 실행할 경우 foo.c가 A 즉 등록되었다고 표시된다. 아직 서버 저장소로 이 파일이 전송된 것은 아님에 유의하자.

## commit

이제 로컬에서 작업한 모든 파일들, 추가한 파일들, 삭제한 파일들은 저장을 통해 현재 로컬 폴더안의 파일들에만 적용된 상태이다. 서버 저장소에도 그 내용을 반영할려면 svn commit이란 명령어를 통해 가능하다. 

``` shell
% export SVN_EDITOR=vi
% svn commit
```

svn commit을 실행하면 현재 작업내용에 대한 로그를 작성할 수 있는 편집기가 실행된다. 여기서는 vi를 편집기로 사용하기 위해 먼저 SVN_EDITOR 환경변수를 vi로 설정하였다. 이것을 .bashrc 등에 넣어두면 매번 실행할 필요가 없을 것이다.

vi 명령어를 이용하여 텍스트를 입력하고 :wq를 입력하여 종료하면 이후에 svn 저장소로 수정된 파일들이 전송되어 저장소의 버젼이 1증가하게 된다.


## update

자 이제 나의 로컬 폴더는 내가 현재 작업중이므로 가장 최신 데이타를 가지고 있으며 svn commit을 통해 서버로 전송되었으므로 저장소에 저장된 파일들도 최신버젼이 되었다. 하지만 다른 사용자가 이미 전에 svn checkout을 통해 저장소를 복제하고 작업중이라면 아직 방금 내가 반영한 파일들이 임의의 사용자의 로컬 폴더로 강제로 적용되지는 않는다. 그 사용자가 서버의 최신 파일들을 자신의 로컬 폴더로 전송받기를 원할때 서버에서 파일들을 내려받아 내 폴더에 덮어쓰게 된다. 이것은 svn update 명령어로 쉽게 처리된다. 다음의 예를 살펴보자.

``` shell
% vi boo.c
% ls
boo.c
% svn update
adding foo.c ...
% ls
boo.c foo.c
```
만약 현재 foo.c를 수정중에 있는데 다른 사용자가 같은 파일 foo.c의 다른위치를 수정하여 commit을 수행하였다면, svn update에 의해 서버 내용이 나의 로컬 폴더로 전송되면서 현재 내가 작업중인 foo.c와 merge된다. 만약 같은 라인을 수정중이었다면 conflict 가 발생하고 foo.mine, foo.r01, foo.r02 와 같이 현재 작업중인 나의 파일, 이전 버젼의 foo.c 이후 버젼 (즉 다른 사용자가 편집하고 commit한 foo.c)로 파일 3개로 복제되어 사용자가 수동으로 해결하도록 업데이트를 멈추게 된다. 사용자는 양쪽 파일을 일일이 확인하며 최종 파일을 편집하고 생성된 3개를 삭제한 뒤 foo.c를 commit 해야 한다.

## delete

커맨스 셀에서 rm 명령어를 이용하여 파일을 직접 삭제할 수 있다. 만약 삭제할 파일이 서버 저장소에 관리되고 있다면 로컬 폴더에 있는 파일의 삭제가 서버로 바로 반영되는 것이 아님에 주의하자. 즉 셀에서 직접 삭제하더러도 서버는 여전희 최신 버젼이며 그 파일이 존재해야 하므로 svn update를 실행할 경우 다시 서버의 최신 버젼인 내용을 로컬 폴더에 반영하게 된다. 다음의 명령어 예를 살펴보자.

``` shell
% ls 
doo.c foo.c
% rm -rf doo.c
% ls
foo.c
% svn status
doo.c     missing
% svn update
Restoring doo.c
% ls
doo.c foo.c
```

만약 저장소에도 삭제하기를 원한다면 svn delete 명령어를 수행해야 한다. svn delete를 수행하면 파일은 즉시 지워지나 이것은 어디까지나 삭제가 예약되었다는 것이지 서버에 삭제 명령어가 전달되어 저장소에 있는 파일이 직접 지워진 상태는 아니다.

``` shell
% svn delete doo.c
% ls 
doo.c      D
% svn commit
Deleting doo.c
```

svn delete가 등록되었다면 이것은 svn add 등과 같이 수정,삭제,추가 명령어가 예약된 상태로 svn commit을 실행할 때 일괄 수행될 것이다.



